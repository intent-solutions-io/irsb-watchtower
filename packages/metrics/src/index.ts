import {
  Registry,
  Counter,
  Gauge,
  collectDefaultMetrics,
} from 'prom-client';

/**
 * Shared Prometheus metrics for IRSB Watchtower
 *
 * Used by both API and Worker packages for consistent metrics collection.
 */

// Create a new registry
export const registry = new Registry();

// Collect default Node.js metrics (memory, CPU, etc.)
collectDefaultMetrics({ register: registry });

/**
 * Total number of scan ticks executed
 */
export const ticksTotal = new Counter({
  name: 'watchtower_ticks_total',
  help: 'Total number of scan ticks executed',
  labelNames: ['chainId'] as const,
  registers: [registry],
});

/**
 * Total number of alerts generated
 */
export const alertsTotal = new Counter({
  name: 'watchtower_alerts_total',
  help: 'Total number of alerts generated by rules',
  labelNames: ['ruleId', 'severity', 'chainId'] as const,
  registers: [registry],
});

/**
 * Total number of errors encountered
 */
export const errorsTotal = new Counter({
  name: 'watchtower_errors_total',
  help: 'Total number of errors encountered',
  labelNames: ['type', 'chainId'] as const,
  registers: [registry],
});

/**
 * Last processed block number per chain
 */
export const lastBlock = new Gauge({
  name: 'watchtower_last_block',
  help: 'Last processed block number',
  labelNames: ['chainId'] as const,
  registers: [registry],
});

/**
 * Total number of actions executed
 */
export const actionsTotal = new Counter({
  name: 'watchtower_actions_total',
  help: 'Total number of actions executed',
  labelNames: ['actionType', 'status', 'chainId'] as const,
  registers: [registry],
});

/**
 * Current number of active scans in progress
 */
export const activeScans = new Gauge({
  name: 'watchtower_active_scans',
  help: 'Number of scan cycles currently in progress',
  labelNames: ['chainId'] as const,
  registers: [registry],
});

/**
 * Scan cycle duration in milliseconds
 */
export const scanDuration = new Gauge({
  name: 'watchtower_scan_duration_ms',
  help: 'Duration of last scan cycle in milliseconds',
  labelNames: ['chainId'] as const,
  registers: [registry],
});

/**
 * Metrics helper functions
 */
export const metrics = {
  /**
   * Record a scan tick
   */
  recordTick(chainId: number): void {
    ticksTotal.inc({ chainId: String(chainId) });
  },

  /**
   * Record an alert/finding
   */
  recordAlert(ruleId: string, severity: string, chainId: number): void {
    alertsTotal.inc({ ruleId, severity, chainId: String(chainId) });
  },

  /**
   * Record an error
   */
  recordError(type: string, chainId?: number): void {
    errorsTotal.inc({ type, chainId: chainId ? String(chainId) : 'unknown' });
  },

  /**
   * Update last processed block
   * Note: prom-client doesn't support bigint, so we convert to number.
   * This is safe for current Ethereum block numbers but may lose precision
   * for very large values (> Number.MAX_SAFE_INTEGER).
   */
  setLastBlock(chainId: number, blockNumber: bigint): void {
    if (blockNumber > BigInt(Number.MAX_SAFE_INTEGER)) {
      console.warn(
        `[Metrics] Block number ${blockNumber} exceeds MAX_SAFE_INTEGER. Metric will lose precision.`
      );
    }
    lastBlock.set({ chainId: String(chainId) }, Number(blockNumber));
  },

  /**
   * Record an action execution
   */
  recordAction(actionType: string, status: 'success' | 'failure' | 'dry_run', chainId: number): void {
    actionsTotal.inc({ actionType, status, chainId: String(chainId) });
  },

  /**
   * Increment active scans
   */
  scanStarted(chainId: number): void {
    activeScans.inc({ chainId: String(chainId) });
  },

  /**
   * Decrement active scans
   */
  scanCompleted(chainId: number): void {
    activeScans.dec({ chainId: String(chainId) });
  },

  /**
   * Record scan duration
   */
  recordScanDuration(chainId: number, durationMs: number): void {
    scanDuration.set({ chainId: String(chainId) }, durationMs);
  },

  /**
   * Get metrics output for Prometheus
   */
  async getMetrics(): Promise<string> {
    return registry.metrics();
  },

  /**
   * Get content type for metrics response
   */
  getContentType(): string {
    return registry.contentType;
  },
};
